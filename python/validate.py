import csv
from collections import Counter, defaultdict
from pathlib import Path
from typing import Dict, List, Tuple
import argparse

REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_TRADES = REPO_ROOT / "data" / "trades.csv"
DEFAULT_EXCEPTIONS = REPO_ROOT / "data" / "exceptions.csv"
DEFAULT_OUT = REPO_ROOT / "docs" / "sample-output" / "summary.md"

REQUIRED_TRADE_FIELDS = [
    "trade_id", "trade_date", "counterparty", "product", "currency",
    "notional", "trade_status", "book", "portfolio", "settle_date"
]

Row = Dict[str, str]

def compute_kpis(trades: List[Row], exceptions: List[Row]) -> Tuple[dict, dict]:
    total_trades = len(trades)
    break_trades = [t for t in trades if normalize_value(t.get("trade_status")) == "Break"]
    break_rate = (len(break_trades) / total_trades * 100) if total_trades else 0.0

    # Missing critical fields in trades
    missing_by_field = Counter()
    trades_with_missing = 0
    for t in trades:
        missing_fields = [f for f in REQUIRED_TRADE_FIELDS if is_missing(t.get(f))]
        if missing_fields:
            trades_with_missing += 1
            missing_by_field.update(missing_fields)

    open_ex = [
        e for e in exceptions
        if normalize_value(e.get("status")).lower() in {"open", "investigating"}
    ]

    breakdown = {
        "break_trades": break_trades,
        "open_exceptions": open_ex,
        "missing_by_field": missing_by_field,
    }

    kpis = {
        "total_trades": total_trades,
        "break_count": len(break_trades),
        "break_rate": break_rate,
        "total_exceptions": len(exceptions),
        "open_exceptions": len(open_ex),
        "trades_with_missing": trades_with_missing,
    }

    return kpis, breakdown

def build_report_lines(trades: List[Row], exceptions: List[Row], kpis: dict, breakdown: dict) -> List[str]:
    break_trades = breakdown["break_trades"]
    open_ex = breakdown["open_exceptions"]
    missing_by_field = breakdown["missing_by_field"]

    ex_by_type = Counter(normalize_value(e.get("exception_type")) or "UNKNOWN" for e in exceptions)
    ex_by_sev = Counter(normalize_value(e.get("severity")) or "UNKNOWN" for e in exceptions)
    ex_by_owner = Counter(normalize_value(e.get("owner")) or "UNKNOWN" for e in exceptions)

    breaks_by_cp = Counter(normalize_value(t.get("counterparty")) or "UNKNOWN" for t in break_trades)
    breaks_by_product = Counter(normalize_value(t.get("product")) or "UNKNOWN" for t in break_trades)

    def top_list(counter: Counter, n=5):
        return counter.most_common(n)

    lines: List[str] = []
    lines.append("# Sample Validation Summary\n")
    lines.append("This report is generated from the demo CSVs in `data/`.\n")

    lines.append("## Key KPIs\n")
    lines.append(f"- Total trades: **{kpis['total_trades']}**\n")
    lines.append(f"- Trades in Break status: **{kpis['break_count']}** (**{kpis['break_rate']:.1f}%**)\n")
    lines.append(f"- Total exceptions: **{kpis['total_exceptions']}**\n")
    lines.append(f"- Open/Investigating exceptions: **{kpis['open_exceptions']}**\n")
    lines.append(f"- Trades with missing critical fields: **{kpis['trades_with_missing']}**\n")

    lines.append("\n## Break queue drivers (top)\n")
    for label, counter in [("Counterparties", breaks_by_cp), ("Products", breaks_by_product)]:
        lines.append(f"\n**{label}**\n")
        for k, v in top_list(counter, 5):
            lines.append(f"- {k}: {v}\n")

    lines.append("\n## Exception breakdown\n")
    lines.append("\n**By type**\n")
    for k, v in top_list(ex_by_type, 10):
        lines.append(f"- {k}: {v}\n")

    lines.append("\n**By severity**\n")
    for k, v in top_list(ex_by_sev, 10):
        lines.append(f"- {k}: {v}\n")

    lines.append("\n**By owner**\n")
    for k, v in top_list(ex_by_owner, 10):
        lines.append(f"- {k}: {v}\n")

    lines.append("\n## Missing-field hot spots (trades)\n")
    if not missing_by_field:
        lines.append("- No missing critical fields detected in demo trades.\n")
    else:
        for k, v in missing_by_field.most_common():
            lines.append(f"- {k}: {v}\n")

    lines.append("\n---\n")
    lines.append("Generated by `python/validate.py`.\n")

    return lines

def read_csv(path: Path):
    with path.open(newline="", encoding="utf-8-sig") as f:
        reader = csv.DictReader(f)
        reader.fieldnames = [normalize_key(h) for h in (reader.fieldnames or [])]
        rows = []
        for row in reader:
            rows.append({normalize_key(k): v for k, v in row.items()})
        return rows

def normalize_key(k: str) -> str:
    # Handles UTF-8 BOM and weird leading/trailing whitespace in headers
    return (k or "").replace("\ufeff", "").strip()

def normalize_value(v) -> str:
    return "" if v is None else str(v).strip()

def is_missing(v) -> bool:
    return normalize_value(v) == ""

def parse_args():
    p = argparse.ArgumentParser(description="Generate a reconciliation/exception summary from demo datasets.")
    p.add_argument("--trades", type=Path, default=DEFAULT_TRADES, help="Path to trades CSV")
    p.add_argument("--exceptions", type=Path, default=DEFAULT_EXCEPTIONS, help="Path to exceptions CSV")
    p.add_argument("--out", type=Path, default=DEFAULT_OUT, help="Output markdown path")
    return p.parse_args()

def write_exceptions_by_type_csv(out_path: Path, exceptions: List[Row]) -> Path:
    out_csv = out_path.parent / "exceptions_by_type.csv"
    ex_by_type = Counter(normalize_value(e.get("exception_type")) or "UNKNOWN" for e in exceptions)

    rows = sorted(ex_by_type.items(), key=lambda x: (-x[1], x[0]))
    with out_csv.open("w", newline="", encoding="utf-8") as f:
        w = csv.writer(f)
        w.writerow(["exception_type", "count"])
        w.writerows(rows)

    return out_csv

def main():
    args = parse_args()
    trades = read_csv(args.trades)
    exceptions = read_csv(args.exceptions)

    kpis, breakdown = compute_kpis(trades, exceptions)
    lines = build_report_lines(trades, exceptions, kpis, breakdown)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    args.out.write_text("".join(lines), encoding="utf-8")
    print(f"Wrote report: {args.out}")

    total_trades = len(trades)
    break_trades = [t for t in trades if normalize_value(t.get("trade_status")) == "Break"]             
    break_rate = (len(break_trades) / total_trades * 100) if total_trades else 0.0

    # Missing critical fields in trades
    missing_by_field = Counter()
    trades_with_missing = 0
    for t in trades:
        missing_fields = [f for f in REQUIRED_TRADE_FIELDS if is_missing(t.get(f))]
        if missing_fields:
            trades_with_missing += 1
            missing_by_field.update(missing_fields)

    # Exceptions KPIs
    open_ex = [e for e in exceptions if normalize_value(e.get("status")).lower() in {"open", "investigating"}]
    ex_by_type = Counter((e.get("exception_type") or "UNKNOWN").strip() for e in exceptions)
    ex_by_sev = Counter((e.get("severity") or "UNKNOWN").strip() for e in exceptions)
    ex_by_owner = Counter((e.get("owner") or "UNKNOWN").strip() for e in exceptions)

    # Breaks by counterparty/product
    breaks_by_cp = Counter((t.get("counterparty") or "UNKNOWN").strip() for t in break_trades)
    breaks_by_product = Counter((t.get("product") or "UNKNOWN").strip() for t in break_trades)

    # Build report
    args.out.parent.mkdir(parents=True, exist_ok=True)

    lines = []
    lines.append("# Sample Validation Summary\n")
    lines.append("This report is generated from the demo CSVs in `data/`.\n")

    lines.append("## Key KPIs\n")
    lines.append(f"- Total trades: **{total_trades}**\n")
    lines.append(f"- Trades in Break status: **{len(break_trades)}** (**{break_rate:.1f}%**) \n")
    lines.append(f"- Total exceptions: **{len(exceptions)}**\n")
    lines.append(f"- Open/Investigating exceptions: **{len(open_ex)}**\n")
    lines.append(f"- Trades with missing critical fields: **{trades_with_missing}**\n")

    def top_list(counter: Counter, n=3):
        return counter.most_common(n)

    lines.append("\n## Break queue drivers (top)\n")
    for label, counter in [("Counterparties", breaks_by_cp), ("Products", breaks_by_product)]:
        lines.append(f"\n**{label}**\n")
        for k, v in top_list(counter, 5):
            lines.append(f"- {k}: {v}\n")

    lines.append("\n## Exception breakdown\n")
    lines.append("\n**By type**\n")
    for k, v in top_list(ex_by_type, 10):
        lines.append(f"- {k}: {v}\n")

    lines.append("\n**By severity**\n")
    for k, v in top_list(ex_by_sev, 10):
        lines.append(f"- {k}: {v}\n")

    lines.append("\n**By owner**\n")
    for k, v in top_list(ex_by_owner, 10):
        lines.append(f"- {k}: {v}\n")

    lines.append("\n## Missing-field hot spots (trades)\n")
    if not missing_by_field:
        lines.append("- No missing critical fields detected in demo trades.\n")
    else:
        for k, v in missing_by_field.most_common():
            lines.append(f"- {k}: {v}\n")

    lines.append("\n---\n")
    lines.append("Generated by `python/validate.py`.\n")

    args.out.write_text("".join(lines), encoding="utf-8")
    print(f"Wrote report: {args.out}")

    csv_path = write_exceptions_by_type_csv(args.out, exceptions)
    print(f"Wrote CSV: {csv_path}")

if __name__ == "__main__":
    main()